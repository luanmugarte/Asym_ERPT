cambio_switching <- dados %>%
dplyr::select(cambio) %>%
slice(-1)
# Escolha das variáveis do modelo
if (comm_endo == T) {
modelo_endo <- dados %>%
dplyr::select(comm,cambio, DA_variable,desemprego,ipca) %>%
mutate(across(!c(desemprego,ipca), ~ (as.numeric(.) - dplyr::lag(as.numeric(.)))/dplyr::lag(as.numeric(.)))) %>%
mutate(ipca = ipca/100) %>%
drop_na()
} else {
modelo_endo <- dados %>%
dplyr::select(cambio, DA_variable,desemprego,ipca) %>%
mutate(across(!c(ipca,desemprego), ~ (as.numeric(.) - dplyr::lag(as.numeric(.)))/dplyr::lag(as.numeric(.)))) %>%
mutate(ipca = as.numeric(ipca)/100) %>%
mutate(desemprego = as.numeric(desemprego)) %>%
drop_na()
}
modelo_endo
# Escolha das variáveis exógenas, caso exista
# OBS: é necessário ajustar a configuração na função de estimação
# Nome do Modelo para exportar figuras
# Primeira parte: variáveis exógenas
# Segunda parte: variáveis endógenas de demanda agregada
if (model_trend == 1){
name_trend = 'trend'
} else {
name_trend = 'notrend'
}
name_trend
if (contemp_effect == 1){
contemp_effect_lp = modelo_exog
contemp_effect = '_CE'
} else {
contemp_effect_lp = NULL
contemp_effect = ''
}
if (comm_endo == T) {
nome_modelo = paste0(toupper(modelo),
'_exo',
'[',
name_trend,
']_endo[',
DA_variable,
paste0('(',as.character(lag_endog),')]'),
paste0('_gamma[',as.character(gamma_transition),']')
)
} else {
nome_modelo = paste0(toupper(modelo),
'_exo',
contemp_effect,
'[',
'comm',
paste0('(',as.character(lag_exog),')_'),
name_trend,
']_endo[',
DA_variable,
paste0('(',as.character(lag_endog),')]'),
paste0('_gamma[',as.character(gamma_transition),']')
)
}
# Seleção de defasagem ótima
VARselect(modelo_endo)
# lag_endog <- VARselect(modelo_endo)$selection[2]
lag <- stats::lag
# Estimando as projeções locais ####
# Parâmetros e configurações
if (comm_endo == T) {
results_nl <- lp_nl(
modelo_endo, # Variáveis endógenas
lags_endog_lin = lag_endog, # Lags do modelo
lags_endog_nl = lag_endog, # Lags do modelo
shock_type = 0, # Tipo de choques: no caso, 0 é de 1 desvio padrão
confint = 1.96, # Intervalo de confiança de 95%
use_nw = T, # Usar erros padrão de Newey-West para as respostas ao impulso (correção de viés)
hor = hor_lps, # Horizonte para as LP
switching = modelo_endo['cambio'], # Definição da série de transição
lag_switching = T, # Uso da variável de transição de forma defasada
use_hp = T, # Usar filtro de HP para decompor
lambda = lambda_hp, # Lambda para o filtro HP, 14400 é mensal
trend = model_trend, # Sem variável de tendência
gamma = gamma_transition, # Definição de gamma para a função de transição
contemp_data = NULL, # Variáveis exógenas com efeito contemporâneo
exog_data = NULL, # Variáveis exógenas com efeitos defasados
lags_exog = NULL # Lags das variáveis exógenas
)
} else {
results_nl <- lp_nl(
modelo_endo, # Variáveis endógenas
lags_endog_lin = lag_endog, # Lags do modelo
lags_endog_nl = lag_endog, # Lags do modelo
shock_type = 0, # Tipo de choques: no caso, 0 é de 1 desvio padrão
confint = 1.96, # Intervalo de confiança de 95%
use_nw = T, # Usar erros padrão de Newey-West para as respostas ao impulso (correção de viés)
hor = hor_lps, # Horizonte para as LP
switching = cambio_switching, # Definição da série de transição
lag_switching = T, # Uso da variável de transição de forma defasada
use_hp = T, # Usar filtro de HP para decompor
lambda = lambda_hp, # Lambda para o filtro HP, 14400 é mensal
trend = model_trend, # Sem variável de tendência
gamma = gamma_transition, # Definição de gamma para a função de transição
contemp_data = contemp_effect_lp, # Variáveis exógenas com efeito contemporâneo
exog_data = modelo_exog, # Variáveis exógenas com efeitos defasados
lags_exog = lag_exog # Lags das variáveis exógenas
)
}
# Obtendo o objeto dos plots ####
nl_plots <- plot_nl(results_nl)
# Criando diretório para exportar gráficos
setwd('/home/luanmugarte/Artigos/Asym_ERPT/')
ifelse(!dir.exists(file.path('Output/Figures')),
dir.create(file.path('Output/Figures')),
FALSE)
ifelse(!dir.exists(file.path('Output/Figures', nome_modelo)),
dir.create(file.path('Output/Figures', nome_modelo)),
FALSE)
setwd(file.path('Output/Figures/', nome_modelo))
# Regime 1 é a 1 - função de transição.
# Regime 2 é a função de transição.
if (modelo == 'mensal') {
transition_function <- as.xts(ts(results_nl$fz, start = c(1999,9), end = c(2020,2), frequency = 12))
} else {
transition_function <- as.xts(ts(results_nl$fz, start = c(1999,4), end = c(2019,4), frequency = 4))
}
transition_function["2002:10"]
plot(transition_function)
date <- time(transition_function)
date
if (modelo == 'mensal') {
if ( (transition_function['2002:8'] < 0.2) &&
(transition_function['2002:9'] < 0.2) &&
(transition_function['2002:10'] < 0.2)) {
regime_1 = 'Regime de Depreciação'
regime_2 = 'Regime de Apreciação'
} else {
regime_1 = 'Regime de Apreciação'
regime_2 = 'Regime de Depreciação'
}
} else {
if ((transition_function['2002:7'] < 0.2) &&
(transition_function['2002:10'] < 0.2)) {
regime_1 = 'Regime de Depreciação'
regime_2 = 'Regime de Apreciação'
} else {
regime_1 = 'Regime de Apreciação'
regime_2 = 'Regime de Depreciação'
}
}
modelo
if (modelo == 'mensal') {
date <- date[max(c(lag_endog,lag_exog)):length(date)]
} else {
date <- date[(max(c(lag_endog,lag_exog))-1):(length(date)-1)]
}
length(date)
length(results_nl$fz)
date <- date[(max(c(lag_endog,lag_exog)):(length(date))]
}
length(date)
length(results_nl$fz)
# Criando dataframe dos dados
df <- tibble(bind_cols(results_nl$fz,date), .name_repair = ~c('transition_function','date'))
# Plotando o gráfico da função de transição
ggplot(df)  +
# geom_rect(data = rects, aes(xmin = xstart, xmax = xend, ymin = -Inf, ymax = Inf, fill = col), alpha = 0.4, show.legend = F) +
geom_line(aes(x=date, y=transition_function), size = 0.75, color = 'darkred') +
scale_x_continuous(breaks=seq(1999.5,2020,0.5),
labels=paste(c("Jun",'Jan'),c(1999,rep(2000:2019,each=2),2020)),expand = c(0, 0)) +
labs(title = paste0('Função de Transição - ',regime_2)) +
scale_fill_brewer(palette="Blues") +
ylab('') +
xlab('') +
theme_classic() +
theme(  panel.grid = element_blank(),
panel.border = element_blank(),
legend.position="right",
legend.title = element_blank(),
plot.title = element_text(hjust = 0.5),
# plot.title = ggtext::element_markdown(size = 11),
legend.text = element_text(size=10),
legend.key = element_rect(colour = "black"),
legend.box.background = element_rect(colour = "black", size = 1),
axis.text.x = element_text(angle = 45, vjust = 0.5, hjust = 0.6,size=12, colour = 'black',face = 'bold'),
axis.text.y = element_text(size=12,face = 'bold'))
ggsave(paste0('Funcao_Transicao'),device = "png",width = 12, height = 8, units = "cm",scale = 2.5)
# Funções Impulso Resposta ####
# IRF - Regime 1
# Criando um vetor que contem os objetos dos plots
plot_lst <- vector("list", length = length(modelo_endo))
# For loop para fazer o gráfico da IRF para cada variável de resposta
for (i in 1:length(modelo_endo)) {
IRF_s1 <- tibble(bind_cols(results_nl$irf_s1_mean[response,,i],
results_nl$irf_s1_up[response,,i],
results_nl$irf_s1_low[response,,i]),
.name_repair = ~ c('IRF','IRF_upper','IRF_lower'))
plot_lst[[i]] <- ggplot(IRF_s1)  +
geom_ribbon(aes(x=c(0:hor_lps), ymin=IRF, ymax =IRF_upper), fill = "GREY90") +
geom_ribbon(aes(x=c(0:hor_lps), ymin=IRF, ymax =IRF_lower), fill = "GREY90") +
geom_line(aes(x=c(0:hor_lps), y=IRF_upper), color = "GREY70") +
geom_line(aes(x=c(0:hor_lps), y=IRF_lower), color = "GREY70") +
geom_hline(yintercept = 0, colour= 'darkgrey', linetype = 'dashed') +
geom_line(aes(x=c(0:hor_lps), y=IRF), colour = 'cadetblue', size = 0.75) +
scale_x_continuous(name = "",breaks=seq(0,18,1),
) +
labs(title = paste0('Resposta do IPCA ao choque de ',colnames(modelo_endo[,i]),' - ',regime_1)) +
ylab('') +
theme_classic() +
theme(  panel.grid = element_blank(),
panel.border = element_blank(),
legend.position="right",
legend.title = element_text(hjust = 0.5),
legend.text = element_text(size=10),
legend.key = element_rect(colour = "black"),
legend.box.background = element_rect(colour = "black", size = 1),
plot.margin=grid::unit(c(0,-2,0,-5), "mm"),
plot.title = ggtext::element_markdown(size = 9, colour = 'black'),
axis.text.x = element_text(angle = 45, vjust = 0.6, hjust = 0.6,size=11, colour = 'black'),
axis.text.y = element_text(size=11,colour = 'black'))
}
ggdraw() +
draw_plot(plot_lst[[1]], x = 0, y = 0.5, height = .5, width = .5) +
draw_plot(plot_lst[[2]], x = 0.5, y = 0.5, height = .5, width = .5) +
draw_plot(plot_lst[[3]], x = 0, y = 0, height = .5, width = .5) +
draw_plot(plot_lst[[4]], x = 0.5, y = 0, height = .5, width = .5)
# ggsave(paste0(nome_modelo,'_',regime_1),device = "png",width = 12, height = 8, units = "cm",scale = 2.5)
ggsave(paste0('IRF_IPCA_',regime_1),device = "png",width = 12, height = 8, units = "cm",scale = 2.5)
# IRF - Regime 2
# Criando um vetor que contem os objetos dos plots
plot_lst <- vector("list", length = length(modelo_endo))
# For loop para fazer o gráfico da IRF para cada variável de resposta
for (i in 1:length(modelo_endo)) {
IRF_s2 <- tibble(bind_cols(results_nl$irf_s2_mean[response,,i],
results_nl$irf_s2_up[response,,i],
results_nl$irf_s2_low[response,,i]),
.name_repair = ~ c('IRF','IRF_lower','IRF_upper'))
plot_lst[[i]] <- ggplot(IRF_s2)  +
geom_ribbon(aes(x=c(0:hor_lps), ymin=IRF, ymax =IRF_upper), fill = "GREY90") +
geom_ribbon(aes(x=c(0:hor_lps), ymin=IRF, ymax =IRF_lower), fill = "GREY90") +
geom_line(aes(x=c(0:hor_lps), y=IRF_upper), color = "GREY70") +
geom_line(aes(x=c(0:hor_lps), y=IRF_lower), color = "GREY70") +
geom_hline(yintercept = 0, colour= 'darkgrey', linetype = 'dashed') +
geom_line(aes(x=c(0:hor_lps), y=IRF), colour = 'bisque3', size = 0.75) +
scale_x_continuous(name = "",breaks=seq(0,18,1),
) +
labs(title = paste0('Resposta do IPCA ao choque de ',colnames(modelo_endo[,i]),' - ',regime_2)) +
ylab('') +
theme_classic() +
theme(  panel.grid = element_blank(),
panel.border = element_blank(),
legend.position="right",
legend.title = element_text(hjust = 0.5),
legend.text = element_text(size=10),
legend.key = element_rect(colour = "black"),
legend.box.background = element_rect(colour = "black", size = 1),
plot.margin=grid::unit(c(0,-2,0,-5), "mm"),
plot.title = ggtext::element_markdown(size = 9, colour = 'black'),
axis.text.x = element_text(angle = 45, vjust = 0.6, hjust = 0.6,size=11, colour = 'black'),
axis.text.y = element_text(size=11,colour = 'black'))
}
ggdraw() +
draw_plot(plot_lst[[1]], x = 0, y = 0.5, height = .5, width = .5) +
draw_plot(plot_lst[[2]], x = 0.5, y = 0.5, height = .5, width = .5) +
draw_plot(plot_lst[[3]], x = 0, y = 0, height = .5, width = .5) +
draw_plot(plot_lst[[4]], x = 0.5, y = 0, height = .5, width = .5)
# ggsave(paste0(nome_modelo,'_',regime_2),device = "png",width = 12, height = 8, units = "cm",scale = 2.5)
ggsave(paste0('IRF_IPCA_',regime_2),device = "png",width = 12, height = 8, units = "cm",scale = 2.5)
# Calculando o repasse cambial conforme Belaisch (2003) ####
# Criando tibble com os dados de CI e da LP (Regime 1)
RC_r1 <- tibble(bind_cols(cumsum((results_nl$irf_s1_mean[response,,cambio_shock])
/cumsum(results_nl$irf_s1_mean[cambio_shock,,cambio_shock])),
results_nl$irf_s1_mean[response,,cambio_shock],
results_nl$irf_s1_up[response,,cambio_shock],
results_nl$irf_s1_low[response,,cambio_shock],
results_nl$irf_s1_mean[cambio_shock,,cambio_shock],
results_nl$irf_s1_up[cambio_shock,,cambio_shock],
results_nl$irf_s1_low[cambio_shock,,cambio_shock]),
.name_repair = ~ c('RC',
'IPCA_mean',
'IPCA_lower',
'IPCA_upper',
'cambio_mean',
'cambio_upper',
'cambio_lower'))
# Criando tibble que define os momentos de significância estatística de ambos as LP's
df.new <- RC_r1 %>%
mutate(., sig_RC = if_else( ((IPCA_lower > 0) & (IPCA_upper > 0) | (IPCA_lower < 0) & (IPCA_upper < 0)) &
((cambio_lower >0 ) & (cambio_upper > 0)  | (cambio_lower <0) & (cambio_upper < 0)),
1,
0))
# Criando o dataframe que estabelece os momentos a serem localizados pelo ggplot
rects <- data.frame(xstart = which(df.new['sig_RC'] == 1), xend = (which(df.new['sig_RC'] == 1)+1))
rects
# Criando o gráfico
RC_r1_plot <- ggplot(RC_r1)  +
geom_rect(data = rects, aes(xmin = xstart, xmax = xend, ymin = -Inf, ymax = Inf), fill = 'lightblue', alpha = 0.4, show.legend = F) +
geom_hline(yintercept = 0, colour= 'darkgrey', linetype = 'dashed') +
geom_line(aes(x=c(0:hor_lps), y=RC), colour = 'darkgrey', size = 0.75) +
scale_x_continuous(name = "",breaks=seq(0,18,1),) +
scale_y_continuous(name = "",labels = function(x) paste0(x*100, "%"),expand = c(0, 0)) +
labs(title = paste0('Repasse cambial - ',regime_1)) +
ylab('') +
theme_classic() +
theme(  panel.grid = element_blank(),
panel.border = element_blank(),
legend.position="right",
legend.title = element_text(hjust = 0.5),
legend.text = element_text(size=10),
legend.key = element_rect(colour = "black"),
legend.box.background = element_rect(colour = "black", size = 1),
plot.margin=grid::unit(c(0,-2,0,-5), "mm"),
plot.title = ggtext::element_markdown(size = 10, colour = 'black', hjust = 0.5),
axis.text.x = element_text(angle = 45, vjust = 0.6, hjust = 0.6,size=11, colour = 'black'),
axis.text.y = element_text(size=11,colour = 'black'))
# Criando tibble com os dados de CI e da LP (Regime 2)
RC_r2 <- tibble(bind_cols(cumsum((results_nl$irf_s2_mean[response,,cambio_shock])
/cumsum(results_nl$irf_s2_mean[cambio_shock,,cambio_shock])),
results_nl$irf_s2_mean[response,,cambio_shock],
results_nl$irf_s2_up[response,,cambio_shock],
results_nl$irf_s2_low[response,,cambio_shock],
results_nl$irf_s2_mean[cambio_shock,,cambio_shock],
results_nl$irf_s2_up[cambio_shock,,cambio_shock],
results_nl$irf_s2_low[cambio_shock,,cambio_shock]
),
.name_repair = ~ c('RC',
'IPCA_mean',
'IPCA_lower',
'IPCA_upper',
'cambio_mean',
'cambio_upper',
'cambio_lower'))
# Criando tibble que define os momentos de significância estatística de ambos as LP's
df.new <- RC_r2 %>%
mutate(., sig_RC = if_else( ((IPCA_lower > 0) & (IPCA_upper > 0) | (IPCA_lower < 0) & (IPCA_upper < 0)) &
((cambio_lower >0 ) & (cambio_upper > 0)  | (cambio_lower <0) & (cambio_upper < 0)),
1,
0))
# Criando o dataframe que estabelece os momentos a serem localizados pelo ggplot
rects <- data.frame(xstart = which(df.new['sig_RC'] == 1), xend = (which(df.new['sig_RC'] == 1)+1))
rects
# Criando o gráfico
RC_r2_plot <- ggplot(RC_r2)  +
geom_rect(data = rects, aes(xmin = xstart, xmax = xend, ymin = -Inf, ymax = Inf), fill = 'lightblue', alpha = 0.4, show.legend = F) +
geom_hline(yintercept = 0, colour= 'darkgrey', linetype = 'dashed') +
geom_line(aes(x=c(0:hor_lps), y=RC), colour = 'darkgrey', size = 0.75) +
scale_x_continuous(name = "",breaks=seq(0,18,1),) +
scale_y_continuous(name = "",labels = function(x) paste0(x*100, "%"),expand = c(0, 0)) +
labs(title = paste0('Repasse cambial - ',regime_2)) +
ylab('') +
theme_classic() +
theme(  panel.grid = element_blank(),
panel.border = element_blank(),
legend.position="right",
legend.title = element_text(hjust = 0.5),
legend.text = element_text(size=10),
legend.key = element_rect(colour = "black"),
legend.box.background = element_rect(colour = "black", size = 1),
plot.margin=grid::unit(c(0,-2,0,-5), "mm"),
plot.title = ggtext::element_markdown(size = 10, colour = 'black', hjust = 0.5),
axis.text.x = element_text(angle = 45, vjust = 0.6, hjust = 0.6,size=11, colour = 'black'),
axis.text.y = element_text(size=11,colour = 'black'))
# Criando os dois gráficos
ggdraw() +
draw_plot(RC_r1_plot, x = 0, y = 0.5, height = .5, width = 1) +
draw_plot(RC_r2_plot, x = 0, y = 0, height = .5, width = 1)
ggsave(paste0('RC_Belaisch'),device = "png",width = 12, height = 8, units = "cm",scale = 2.5)
# modelo
# if (modelo == 'mensal') {
date <- date[max(c(lag_endog,lag_exog)):length(date)]
# } else {
#   date <- date[(max(c(lag_endog,lag_exog)):(length(date))]
# }
length(date)
length(results_nl$fz)
date <- time(transition_function)
date
date <- date[(max(c(lag_endog,lag_exog))+1):(length(date))]
if (modelo == 'mensal') {
date <- date[max(c(lag_endog,lag_exog)):length(date)]
} else {
date <- date[(max(c(lag_endog,lag_exog))+1):(length(date))]
}
length(date)
length(results_nl$fz)
date <- date[(max(c(lag_endog,lag_exog))+1):length(date)]
if (modelo == 'mensal') {
date <- date[(max(c(lag_endog,lag_exog))+1):length(date)]
} else {
date <- date[(max(c(lag_endog,lag_exog))+1):(length(date))]
}
length(date)
length(results_nl$fz)
source('~/Artigos/Asym_ERPT/Code/Main_Model.R', echo=TRUE)
# Elaboração dos gráficos para o modelo de LP com 4 variáveis endógenas (comm exógeno)
# Obtendo o objeto dos plots ####
nl_plots <- plot_nl(results_nl)
# Criando diretório para exportar gráficos
setwd('/home/luanmugarte/Artigos/Asym_ERPT/')
ifelse(!dir.exists(file.path('Output/Figures')),
dir.create(file.path('Output/Figures')),
FALSE)
ifelse(!dir.exists(file.path('Output/Figures', nome_modelo)),
dir.create(file.path('Output/Figures', nome_modelo)),
FALSE)
setwd(file.path('Output/Figures/', nome_modelo))
# Função de transição ####
# Regime 1 é a 1 - função de transição.
# Regime 2 é a função de transição.
if (modelo == 'mensal') {
transition_function <- as.xts(ts(results_nl$fz, start = c(1999,8), end = c(2020,2), frequency = 12))
} else {
transition_function <- as.xts(ts(results_nl$fz, start = c(1999,4), end = c(2019,4), frequency = 4))
}
transition_function["2002:10"]
plot(transition_function)
date <- time(transition_function)
date
if (modelo == 'mensal') {
if ( (transition_function['2002:8'] < 0.2) &&
(transition_function['2002:9'] < 0.2) &&
(transition_function['2002:10'] < 0.2)) {
regime_1 = 'Regime de Depreciação'
regime_2 = 'Regime de Apreciação'
} else {
regime_1 = 'Regime de Apreciação'
regime_2 = 'Regime de Depreciação'
}
} else {
if ((transition_function['2002:7'] < 0.2) &&
(transition_function['2002:10'] < 0.2)) {
regime_1 = 'Regime de Depreciação'
regime_2 = 'Regime de Apreciação'
} else {
regime_1 = 'Regime de Apreciação'
regime_2 = 'Regime de Depreciação'
}
}
modelo
if (modelo == 'mensal') {
date <- date[(max(c(lag_endog,lag_exog))+1):length(date)]
} else {
date <- date[(max(c(lag_endog,lag_exog))+1):(length(date))]
}
length(date)
length(results_nl$fz)
length(date)
length(results_nl$fz)
length(date)
(max(c(lag_endog,lag_exog))+1)
length(date[(max(c(lag_endog,lag_exog))+1):(length(date))])
length(results_nl$fz)
length(date[(max(c(lag_endog,lag_exog))+1):(length(date))])
length(results_nl$fz)
date <- date[(max(c(lag_endog,lag_exog))+1):length(date)]
length(date)
# Elaboração dos gráficos para o modelo de LP com 4 variáveis endógenas (comm exógeno)
# Obtendo o objeto dos plots ####
nl_plots <- plot_nl(results_nl)
# Criando diretório para exportar gráficos
setwd('/home/luanmugarte/Artigos/Asym_ERPT/')
ifelse(!dir.exists(file.path('Output/Figures')),
dir.create(file.path('Output/Figures')),
FALSE)
ifelse(!dir.exists(file.path('Output/Figures', nome_modelo)),
dir.create(file.path('Output/Figures', nome_modelo)),
FALSE)
setwd(file.path('Output/Figures/', nome_modelo))
# Função de transição ####
# Regime 1 é a 1 - função de transição.
# Regime 2 é a função de transição.
if (modelo == 'mensal') {
transition_function <- as.xts(ts(results_nl$fz, start = c(1999,8), end = c(2020,2), frequency = 12))
} else {
transition_function <- as.xts(ts(results_nl$fz, start = c(1999,4), end = c(2019,4), frequency = 4))
}
transition_function["2002:10"]
plot(transition_function)
date <- time(transition_function)
date
if (modelo == 'mensal') {
if ( (transition_function['2002:8'] < 0.2) &&
(transition_function['2002:9'] < 0.2) &&
(transition_function['2002:10'] < 0.2)) {
regime_1 = 'Regime de Depreciação'
regime_2 = 'Regime de Apreciação'
} else {
regime_1 = 'Regime de Apreciação'
regime_2 = 'Regime de Depreciação'
}
} else {
if ((transition_function['2002:7'] < 0.2) &&
(transition_function['2002:10'] < 0.2)) {
regime_1 = 'Regime de Depreciação'
regime_2 = 'Regime de Apreciação'
} else {
regime_1 = 'Regime de Apreciação'
regime_2 = 'Regime de Depreciação'
}
}
date <- date[(max(c(lag_endog,lag_exog))+1):length(date)]
length(date)
length(results_nl$fz)
date
source('~/Artigos/Asym_ERPT/Code/Main_Model.R', echo=TRUE)
source('~/Artigos/Asym_ERPT/Code/Main_Model.R', echo=TRUE)
source('~/Artigos/Asym_ERPT/Code/Main_Model.R', echo=TRUE)
length(date)
length(results_nl$fz)
source('~/Artigos/Asym_ERPT/Code/Main_Model.R', echo=TRUE)
source('~/Artigos/Asym_ERPT/Code/Main_Model.R', echo=TRUE)
source('~/Artigos/Asym_ERPT/Code/Main_Model.R', echo=TRUE)
source('~/Artigos/Asym_ERPT/Code/Main_Model.R', echo=TRUE)
source('~/Artigos/Asym_ERPT/Code/Main_Model.R', echo=TRUE)
