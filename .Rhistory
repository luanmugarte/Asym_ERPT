dplyr::mutate(sq_trend = trend^2)
}
# Construct (lagged) exogenous data and merge it with lagged endogenous data
if(!(is.null(specs$exog_data))){
x_exog    <- create_lags(specs$exog_data, specs$lags_exog) %>%
`rownames<-`(NULL)
x_lin     <- cbind(x_lin, x_exog)
}
str(x_lin)
# Add contemporaneous data if supplied
if(!(is.null(specs$contemp_data))){
x_contemp <-  specs$contemp_data
x_lin     <- cbind(x_lin, x_contemp)
}
str(x_lin)
# Combine endogenous and exogenous data
yx_all    <- cbind(y_lin, x_lin)   %>%
stats::na.omit()
str(yx_all)
yx_all    <- yx_all[,  !(colSums(yx_all) == Inf)]
str(yx_all)
y_lin     <- yx_all[, 1:ncol(endog_data)]  %>%
as.matrix()
x_lin     <- yx_all[, (ncol(endog_data) + 1):dim(yx_all)[2]] %>%
as.matrix()
str(y_lin)
str(x_lin)
# Check whether z_lin matrix has to be build for 2sls
if(specs$use_twosls == TRUE){
# Compare lag length between endog_lin and lags_exog
z_lag         <- max(specs$lags_endog_lin, specs$lags_exog)
z_lin         <- x_lin[, -1]
z_lin         <- cbind(specs$instrum[(z_lag + 1):dim(specs$instrum)[1], ], z_lin)
# Set instrument variable to NULL if use_twosls = FALSE
} else {
z_lin <- NULL
}
str(y_lin)
str(x_lin)
# Construindo matrizes de coeficients  ####
# Obtendo y_data da função get_mal_chol
y_lin
y_data        <- lapply(seq_len(ncol(y_lin)), function(i) y_lin[,i])
str(y_data)
x_data <- x_lin
str(y_data)
(lapply(y_data, get_resids_ols, x_lin))
# Build matrices
xx
yy           <- as.matrix(y_data)
yy           <- y_lin
xx           <- as.matrix(x_data)
xx           <- cbind(rep(1,nrow(xx)), xx)  # Add vector of ones for constant
str(xx)
str(yy)
# Regression parameters
beta    <- (solve(crossprod(xx))%*%t(xx))%*%yy
beta
# Residuals
resids  <- yy - xx%*%beta
resids
VAR_obj <- VAR(modelo_endo, p = results_nl$specs$lags_endog_nl)
resids_VAR <- residuals(VAR_obj)
resids
# Make matrix of residuals
resid_all     <- matrix(unlist(resids), ncol = specs$endog, byrow = F )
resid_all
# Construindo matriz de choques ####
cov_var       <- stats::cov(resid_all)
cov((resid_all))
# Cholesky decomposition
chol_decomp = NULL
if (is.null(chol_decomp)){
A             <- t(chol(cov_var))
} else {
A <- SVAR(VAR(model_data$modelo_endo,
p = results_nl$specs$lags_endog_nl),
p = specs$lags_endog_nl,
Amat = chol_decomp,
max.iter = 10000)$A
}
D             <- diag(sqrt(diag(cov_var)))
D
A
diag(sqrt(diag(cov_var)))
diag(sqrt(diag(cov_var)))
# Shock Matrix
d <- matrix(NaN, specs$endog, specs$endog)
d
if (specs$shock_type == 0){
for (i in 1:specs$endog){
d[, i]     <-  A[, i]/A[i, i]*D[i, i]
}
} else {
for (i in 1:specs$endog){
d[, i]     <-  A[, i]/A[i, i]
}
}
d
d_chol <- d
std_dev_cambio <- d[4,2]
# Antes é necessário fazer algumas transformações nos dados
nl_data <- create_nl_data(results_nl$specs, model_data$modelo_endo)
y_nl <- nl_data$y_nl
x_nl <- nl_data$x_nl
str(x_nl)
# for (h in 1:specs$hor){   # Accounts for the horizons
h = 1
yy  <-   y_nl[h:dim(y_nl)[1], ]
xx  <-   x_nl[1:(dim(x_nl)[1] - h + 1), ]
xx
yy
ncol(xx)
# Erros padrões de Newey West ####
lag_nw = 1
k = 1
# Estimate coefficients (para a primeira equação de comm como variável endógena)
nw_results        <- lpirfs::newey_west(yy[, k], xx, lag_nw)
b                 <- nw_results[[1]]
cov_nw            <- nw_results[[2]]
str(cov_nw)
str(b)
b
# Make finite sample adjustment
if(isTRUE(specs$adjust_se)) cov_nw  <- cov_nw*nrow(yy)/(nrow(yy) - ncol(xx) - 1)
# Get NW standard errors
std_err        <- sqrt(diag(cov_nw))*specs$confint
sqrt(diag(cov_nw))*specs$confint
specs$confint
# Obtendo IRFs ####
nl_data <- create_nl_data(results_nl$specs, model_data$modelo_endo)
lin_data <- create_lin_data(results_nl$specs, model_data$modelo_endo)
# Matrices to store irfs for each horizon
irf_temp_s1_mean  <-  matrix(NaN, specs$endog, specs$hor + 1)
irf_temp_s1_low   <-  irf_temp_s1_mean
irf_temp_s1_up    <-  irf_temp_s1_mean
irf_temp_s2_mean  <-  matrix(NaN, specs$endog, specs$hor + 1)
irf_temp_s2_low   <-  irf_temp_s2_mean
irf_temp_s2_up    <-  irf_temp_s2_mean
# Arrays to store irfs
irf_s1_mean  <-  array(NaN, dim = c(specs$endog, specs$hor + 1, specs$endog))
irf_s1_low   <-  irf_s1_mean
irf_s1_up    <-  irf_s1_mean
irf_s2_mean  <-  array(NaN, dim = c(specs$endog, specs$hor + 1, specs$endog))
irf_s2_low   <-  irf_s2_mean
irf_s2_up    <-  irf_s2_mean
# Matrices to store OLS parameters for regime 1 & 2
b1_s1      <- matrix(NaN, specs$endog, specs$endog)
b1_low_s1  <- matrix(NaN, specs$endog, specs$endog)
b1_up_s1   <- matrix(NaN, specs$endog, specs$endog)
b1_s2      <- matrix(NaN, specs$endog, specs$endog)
b1_low_s2  <- matrix(NaN, specs$endog, specs$endog)
b1_up_s2   <- matrix(NaN, specs$endog, specs$endog)
# Define coefficient position to extract regime_1 and regime_2 parameters in loop
start_nl_s1   <- 2
end_nl_s1     <- specs$endog + 1
samp_nl_s1    <- start_nl_s1:end_nl_s1
start_nl_s2   <- 2 + specs$endog*specs$lags_endog_nl
end_nl_s2     <- start_nl_s2 + specs$endog - 1
samp_nl_s2    <- start_nl_s2:end_nl_s2
# Make list to store OLS diagnostics for each horizon
diagnost_ols_each_h <- list()
# Make matrix to store OLS diagnostics for each endogenous variable k
diagnost_each_k           <- matrix(NaN, specs$endog,  4)
rownames(diagnost_each_k) <- specs$column_names
colnames(diagnost_each_k) <- c("R-sqrd.", "Adj. R-sqrd.", "F-stat", " p-value")
# Matrices to store OLS parameters for regime 1 & 2
b_store_s1 <- array(NaN, dim = c(specs$endog,specs$endog ,specs$hor))
b_store_s2 <- array(NaN, dim = c(specs$endog,specs$endog ,specs$hor))
stderr_store_s1 <- array(NaN, dim = c(specs$endog,specs$endog ,specs$hor))
stderr_store_s2 <- array(NaN, dim = c(specs$endog,specs$endog ,specs$hor))
nw_lag = NULL
for(s in 1:4) {
for (h in 1:specs$hor){   # Accounts for the horizons
yy  <-   y_nl[h:dim(y_nl)[1], ]
xx  <-   x_nl[1:(dim(x_nl)[1] - h + 1), ]
# Set lag number for Newey-West (1987)
if(is.null(nw_lag)){
lag_nw <- h
} else {
lag_nw <- nw_lag
}
for (k in 1:specs$endog){ # Accounts for the reactions of the endogenous variables
# Get standard errors and point estimates
get_ols_vals <- lpirfs::get_std_err(yy, xx, lag_nw, k, specs)
std_err <- get_ols_vals[[1]]
b       <- get_ols_vals[[2]]
# Extract coefficients
b1_s1[k, ]       <-   b[samp_nl_s1]
b1_low_s1[k, ]   <-   b[samp_nl_s1] - std_err[samp_nl_s1]
b1_up_s1[k, ]    <-   b[samp_nl_s1] + std_err[samp_nl_s1]
b1_s2[k, ]       <-   b[samp_nl_s2]
b1_low_s2[k, ]   <-   b[samp_nl_s2] - std_err[samp_nl_s2]
b1_up_s2[k, ]    <-   b[samp_nl_s2] + std_err[samp_nl_s2]
# Get diagnostocs for summary
get_diagnost              <- lpirfs::ols_diagnost(yy[, k], xx)
diagnost_each_k[k, 1]     <- get_diagnost[[3]]
diagnost_each_k[k, 2]     <- get_diagnost[[4]]
diagnost_each_k[k, 3]     <- get_diagnost[[5]]
diagnost_each_k[k, 4]     <- stats::pf(diagnost_each_k[k, 3], get_diagnost[[6]], get_diagnost[[7]], lower.tail = F)
# b_store_s1[k,,h] <- b[samp_nl_s1]
# b_store_s2[k,,h] <- b[samp_nl_s2]
# stderr_store_s1[k,,h] <- std_err[samp_nl_s1]
# stderr_store_s2[k,,h] <- std_err[samp_nl_s2]
}
# Estimate local projections
irf_temp_s1_mean[, h + 1] <- t(b1_s1        %*%  d[ , s])
irf_temp_s1_low[,  h + 1] <- t(b1_low_s1    %*%  d[ , s])
irf_temp_s1_up[,   h + 1] <- t(b1_up_s1     %*%  d[ , s])
irf_temp_s2_mean[, h + 1] <- t(b1_s2        %*%  d[ , s])
irf_temp_s2_low[,  h + 1] <- t(b1_low_s2    %*%  d[ , s])
irf_temp_s2_up[,   h + 1] <- t(b1_up_s2     %*%  d[ , s])
# Give rownames
rownames(diagnost_each_k) <- paste("h", h, ":", specs$column_names, sep ="")
# Save full summary matrix in list for each horizon
diagnost_ols_each_h[[h]]             <- diagnost_each_k
}
}
results_nl
# Criando os dados ####
endog_data <- model_data$modelo_endo
model_data$modelo_endo
# Data for endogenous variables
y_lin <- endog_data
specs <- results_nl$specs
# Make exogenous lagged data and check, whether lag length is zero
if(specs$lags_endog_lin == 0){
x_lin <- data.frame(x = rep(Inf, nrow(endog_data)))
} else {
x_lin <- create_lags(endog_data, specs$lags_endog_lin)
}
x_lin
results_nl$specs$lags_endog_nl
# Check whether model type is 'iv'.
# 0 = Normal model, 1 = IV model
# Prepare instrument variable and add to exogenous data
if(specs$model_type == 1){
shock             <- specs$shock
colnames(shock)   <- 'shock'
x_lin             <- cbind(shock, x_lin)
}
# Include no trend, trend or quadratic trend
if (specs$trend == 0){
x_lin      <-   x_lin
} else if (specs$trend == 1){
x_lin      <-   x_lin                                           %>%
dplyr::mutate(trend = row_number())
} else {
x_lin      <-   x_lin                                   %>%
dplyr::mutate(trend = row_number())     %>%
dplyr::mutate(sq_trend = trend^2)
}
# Construct (lagged) exogenous data and merge it with lagged endogenous data
if(!(is.null(specs$exog_data))){
x_exog    <- create_lags(specs$exog_data, specs$lags_exog) %>%
`rownames<-`(NULL)
x_lin     <- cbind(x_lin, x_exog)
}
str(x_lin)
# Add contemporaneous data if supplied
if(!(is.null(specs$contemp_data))){
x_contemp <-  specs$contemp_data
x_lin     <- cbind(x_lin, x_contemp)
}
str(x_lin)
# Combine endogenous and exogenous data
yx_all    <- cbind(y_lin, x_lin)   %>%
stats::na.omit()
str(yx_all)
yx_all    <- yx_all[,  !(colSums(yx_all) == Inf)]
str(yx_all)
y_lin     <- yx_all[, 1:ncol(endog_data)]  %>%
as.matrix()
x_lin     <- yx_all[, (ncol(endog_data) + 1):dim(yx_all)[2]] %>%
as.matrix()
str(y_lin)
str(x_lin)
# Check whether z_lin matrix has to be build for 2sls
if(specs$use_twosls == TRUE){
# Compare lag length between endog_lin and lags_exog
z_lag         <- max(specs$lags_endog_lin, specs$lags_exog)
z_lin         <- x_lin[, -1]
z_lin         <- cbind(specs$instrum[(z_lag + 1):dim(specs$instrum)[1], ], z_lin)
# Set instrument variable to NULL if use_twosls = FALSE
} else {
z_lin <- NULL
}
str(y_lin)
str(x_lin)
# Construindo matrizes de coeficients  ####
# Obtendo y_data da função get_mal_chol
y_lin
y_data        <- lapply(seq_len(ncol(y_lin)), function(i) y_lin[,i])
str(y_data)
x_data <- x_lin
str(y_data)
(lapply(y_data, get_resids_ols, x_lin))
# Build matrices
xx
yy           <- as.matrix(y_data)
yy           <- y_lin
xx           <- as.matrix(x_data)
xx           <- cbind(rep(1,nrow(xx)), xx)  # Add vector of ones for constant
str(xx)
str(yy)
# Regression parameters
beta    <- (solve(crossprod(xx))%*%t(xx))%*%yy
beta
# Residuals
resids  <- yy - xx%*%beta
resids
VAR_obj <- VAR(modelo_endo, p = results_nl$specs$lags_endog_nl)
resids_VAR <- residuals(VAR_obj)
resids
# Make matrix of residuals
resid_all     <- matrix(unlist(resids), ncol = specs$endog, byrow = F )
resid_all
# Construindo matriz de choques ####
cov_var       <- stats::cov(resid_all)
cov((resid_all))
# Cholesky decomposition
chol_decomp = NULL
if (is.null(chol_decomp)){
A             <- t(chol(cov_var))
} else {
A <- SVAR(VAR(model_data$modelo_endo,
p = results_nl$specs$lags_endog_nl),
p = specs$lags_endog_nl,
Amat = chol_decomp,
max.iter = 10000)$A
}
D             <- diag(sqrt(diag(cov_var)))
D
A
diag(sqrt(diag(cov_var)))
diag(sqrt(diag(cov_var)))
# Shock Matrix
d <- matrix(NaN, specs$endog, specs$endog)
d
if (specs$shock_type == 0){
for (i in 1:specs$endog){
d[, i]     <-  A[, i]/A[i, i]*D[i, i]
}
} else {
for (i in 1:specs$endog){
d[, i]     <-  A[, i]/A[i, i]
}
}
d
d_chol <- d
std_dev_cambio <- d[4,2]
# Antes é necessário fazer algumas transformações nos dados
nl_data <- create_nl_data(results_nl$specs, model_data$modelo_endo)
y_nl <- nl_data$y_nl
x_nl <- nl_data$x_nl
str(x_nl)
# for (h in 1:specs$hor){   # Accounts for the horizons
h = 1
yy  <-   y_nl[h:dim(y_nl)[1], ]
xx  <-   x_nl[1:(dim(x_nl)[1] - h + 1), ]
xx
yy
ncol(xx)
# Erros padrões de Newey West ####
lag_nw = 1
k = 1
# Estimate coefficients (para a primeira equação de comm como variável endógena)
nw_results        <- lpirfs::newey_west(yy[, k], xx, lag_nw)
b                 <- nw_results[[1]]
cov_nw            <- nw_results[[2]]
str(cov_nw)
str(b)
b
# Make finite sample adjustment
if(isTRUE(specs$adjust_se)) cov_nw  <- cov_nw*nrow(yy)/(nrow(yy) - ncol(xx) - 1)
# Get NW standard errors
std_err        <- sqrt(diag(cov_nw))*specs$confint
sqrt(diag(cov_nw))*specs$confint
specs$confint
# Obtendo IRFs ####
nl_data <- create_nl_data(results_nl$specs, model_data$modelo_endo)
lin_data <- create_lin_data(results_nl$specs, model_data$modelo_endo)
# Matrices to store irfs for each horizon
irf_temp_s1_mean  <-  matrix(NaN, specs$endog, specs$hor + 1)
irf_temp_s1_low   <-  irf_temp_s1_mean
irf_temp_s1_up    <-  irf_temp_s1_mean
irf_temp_s2_mean  <-  matrix(NaN, specs$endog, specs$hor + 1)
irf_temp_s2_low   <-  irf_temp_s2_mean
irf_temp_s2_up    <-  irf_temp_s2_mean
# Arrays to store irfs
irf_s1_mean  <-  array(NaN, dim = c(specs$endog, specs$hor + 1, specs$endog))
irf_s1_low   <-  irf_s1_mean
irf_s1_up    <-  irf_s1_mean
irf_s2_mean  <-  array(NaN, dim = c(specs$endog, specs$hor + 1, specs$endog))
irf_s2_low   <-  irf_s2_mean
irf_s2_up    <-  irf_s2_mean
# Matrices to store OLS parameters for regime 1 & 2
b1_s1      <- matrix(NaN, specs$endog, specs$endog)
b1_low_s1  <- matrix(NaN, specs$endog, specs$endog)
b1_up_s1   <- matrix(NaN, specs$endog, specs$endog)
b1_s2      <- matrix(NaN, specs$endog, specs$endog)
b1_low_s2  <- matrix(NaN, specs$endog, specs$endog)
b1_up_s2   <- matrix(NaN, specs$endog, specs$endog)
# Define coefficient position to extract regime_1 and regime_2 parameters in loop
start_nl_s1   <- 2
end_nl_s1     <- specs$endog + 1
samp_nl_s1    <- start_nl_s1:end_nl_s1
start_nl_s2   <- 2 + specs$endog*specs$lags_endog_nl
end_nl_s2     <- start_nl_s2 + specs$endog - 1
samp_nl_s2    <- start_nl_s2:end_nl_s2
# Make list to store OLS diagnostics for each horizon
diagnost_ols_each_h <- list()
# Make matrix to store OLS diagnostics for each endogenous variable k
diagnost_each_k           <- matrix(NaN, specs$endog,  4)
rownames(diagnost_each_k) <- specs$column_names
colnames(diagnost_each_k) <- c("R-sqrd.", "Adj. R-sqrd.", "F-stat", " p-value")
# Matrices to store OLS parameters for regime 1 & 2
b_store_s1 <- array(NaN, dim = c(specs$endog,specs$endog ,specs$hor))
b_store_s2 <- array(NaN, dim = c(specs$endog,specs$endog ,specs$hor))
stderr_store_s1 <- array(NaN, dim = c(specs$endog,specs$endog ,specs$hor))
stderr_store_s2 <- array(NaN, dim = c(specs$endog,specs$endog ,specs$hor))
nw_lag = NULL
for(s in 1:4) {
for (h in 1:specs$hor){   # Accounts for the horizons
yy  <-   y_nl[h:dim(y_nl)[1], ]
xx  <-   x_nl[1:(dim(x_nl)[1] - h + 1), ]
# Set lag number for Newey-West (1987)
if(is.null(nw_lag)){
lag_nw <- h
} else {
lag_nw <- nw_lag
}
for (k in 1:specs$endog){ # Accounts for the reactions of the endogenous variables
# Get standard errors and point estimates
get_ols_vals <- lpirfs::get_std_err(yy, xx, lag_nw, k, specs)
std_err <- get_ols_vals[[1]]
b       <- get_ols_vals[[2]]
# Extract coefficients
b1_s1[k, ]       <-   b[samp_nl_s1]
b1_low_s1[k, ]   <-   b[samp_nl_s1] - std_err[samp_nl_s1]
b1_up_s1[k, ]    <-   b[samp_nl_s1] + std_err[samp_nl_s1]
b1_s2[k, ]       <-   b[samp_nl_s2]
b1_low_s2[k, ]   <-   b[samp_nl_s2] - std_err[samp_nl_s2]
b1_up_s2[k, ]    <-   b[samp_nl_s2] + std_err[samp_nl_s2]
# Get diagnostocs for summary
get_diagnost              <- lpirfs::ols_diagnost(yy[, k], xx)
diagnost_each_k[k, 1]     <- get_diagnost[[3]]
diagnost_each_k[k, 2]     <- get_diagnost[[4]]
diagnost_each_k[k, 3]     <- get_diagnost[[5]]
diagnost_each_k[k, 4]     <- stats::pf(diagnost_each_k[k, 3], get_diagnost[[6]], get_diagnost[[7]], lower.tail = F)
b_store_s1[k,,h] <- b[samp_nl_s1]
b_store_s2[k,,h] <- b[samp_nl_s2]
stderr_store_s1[k,,h] <- std_err[samp_nl_s1]
stderr_store_s2[k,,h] <- std_err[samp_nl_s2]
}
# Estimate local projections
irf_temp_s1_mean[, h + 1] <- t(b1_s1        %*%  d[ , s])
irf_temp_s1_low[,  h + 1] <- t(b1_low_s1    %*%  d[ , s])
irf_temp_s1_up[,   h + 1] <- t(b1_up_s1     %*%  d[ , s])
irf_temp_s2_mean[, h + 1] <- t(b1_s2        %*%  d[ , s])
irf_temp_s2_low[,  h + 1] <- t(b1_low_s2    %*%  d[ , s])
irf_temp_s2_up[,   h + 1] <- t(b1_up_s2     %*%  d[ , s])
# Give rownames
rownames(diagnost_each_k) <- paste("h", h, ":", specs$column_names, sep ="")
# Save full summary matrix in list for each horizon
diagnost_ols_each_h[[h]]             <- diagnost_each_k
}
}
b_store_s1
b1_s1
b
lag_endog
b[1,]
b1_s1
lag_endog
b[samp_nl_s1]
b
samp_nl_s1
samp_nl_s2
b[samp_nl_s2]
b[samp_nl_s1]
b[samp_nl_s2]
samp_nl_s1*2
samp_nl_s1+5
samp_nl_s1
c(b[samp_nl_s1],
b[samp_nl_s1+5*1],
b[samp_nl_s1+5*2],
b[samp_nl_s1+5*3],
b[samp_nl_s1+5*4])
colnames
colnames(model_data$modelo_endo)
lag_endog
for (j in colnames(model_data$modelo_endo)) {
for (i in lag_endog) {
coefs_names <- paste0(j,'_lag_',i,'s1')
}
}
coefs_names
coefs_names <- vector(length = lag_endog*ncol(model_data$modelo_endo))
coefs_names
for (j in colnames(model_data$modelo_endo)) {
for (i in lag_endog) {
coefs_names <- paste0(j,'_lag_',i,'s1')
}
}
coefs_names += paste0(j,'_lag_',i,'s1')
for (j in colnames(model_data$modelo_endo)) {
for (i in lag_endog) {
coefs_names += paste0(j,'_lag_',i,'s1')
}
}
